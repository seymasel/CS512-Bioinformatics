# -*- coding: utf-8 -*-
"""HW2_NurverSeyma_Sel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hBmO8sUvsz8ZkH2niM_fIozSiYkf8a08
"""

#https://colab.research.google.com/drive/1hBmO8sUvsz8ZkH2niM_fIozSiYkf8a08?usp=sharing
# #MedianStringProblem
# #!pip product 
from itertools import product

def AllKmersInGivenDna(Dna, k):
  DnaKmers = []
  num_iteration = len(Dna) - k + 1
  for i in range(num_iteration):
    kmer = Dna[i:i+k]
    if kmer not in DnaKmers:
      DnaKmers.append(kmer)
  return DnaKmers

def Distance(kmer,Dna,k):
    return min([HammingDistance(kmer,sk,k) for sk in AllKmersInGivenDna(Dna,k)])

def HammingDistance(pattern,text,k):
    return sum([1 for i in range(k) if text[i] != pattern[i]])

def MedianString(DNAs,k):
    allkmers = [''.join(kmer) for kmer in product('ACTG',repeat=k)]
    distancePatternDna = {}
    minString = len(DNAs) * len(allkmers)
    for i in allkmers:
        totalDistance = 0
        for j in range(len(DNAs)):
            totalDistance = Distance(i, DNAs[j],k) + totalDistance
        distancePatternDna[i] = totalDistance
        if totalDistance < minString:
            minString = totalDistance
    for median in distancePatternDna.keys():
        if distancePatternDna[median] == minString:
           print(median)

MedianString(["AAATTGACGCAT","GACGACCACGTT","CGTCAGCGCCTG","GCTGAGCACCGG","AGTACGGGACAG"],3) #GAC

#Functions
nucleotides = 'ACGT'
def Score(Motifs):
    score = 0
    for i in range(len(Motifs[0])):
        j = [motif[i] for motif in Motifs]
        score += (len(j) - max(j.count(nucleotides[0]), j.count(nucleotides[1]), j.count(nucleotides[2]), j.count(nucleotides[3])))
    return score

def ProfileMostProbableKmer(dna, k, profile):
	bestprob = [-1, None]
	nuclocation = {nuc:index for index,nuc in enumerate(nucleotides)}
	for i in range(len(dna)-k+1):
		currentprob = 1
		for j, nuc in enumerate(dna[i:i+k]):
			currentprob = currentprob * profile[j][nuclocation[nuc]]
		if currentprob > bestprob[0]:
			bestprob = [currentprob, dna[i:i+k]]
	return bestprob[1]

def Profile(Motifs):
  profile=[]
  for i in range(len(Motifs[0])):
    countA,countC,countG,countT = 0, 0, 0, 0
    for motif in Motifs:
      if motif[i] == nucleotides[0]:
        countA += 1
      elif motif[i] == nucleotides[1]:
        countC += 1
      elif motif[i] == nucleotides[2]:
        countG += 1
      elif motif[i] == nucleotides[3]:
         countT += 1
    profile.append([countA / len(Motifs), countC / len(Motifs), countG / len(Motifs), countT / len(Motifs)])
  return profile

def RandomMotifs(Dna, k, t):
    rand_motifs = []
    for i in range(t):
        x = randint(0, t)
        rand_motifs.append(Dna[i][x:x+k])
    return rand_motifs

#GreedySearchAlgorithm

def GreedyMotifSearch(DNAs, k, t):
    iterNum = len(DNAs[0])-k+1
    bestScore = k*t
    for i in range(iterNum):
        motifs = [DNAs[0][i:i+k]]
        for j in range(1, t):
            currentProfile = Profile(motifs)
            motifs.append(ProfileMostProbableKmer(DNAs[j], k, currentProfile))
        currentScore = Score(motifs)
        if currentScore < bestScore:
            bestScore = currentScore
            bestMotifs = motifs
    return bestMotifs

GreedyMotifSearch(["GGCGTTCAGGCA","AAGAATCAGTCA","CAAGGAGTTCGC","CACGTCAATCAC","CAATAATATTCG"],3,5)

#RandomizedMotifSearch
from random import randint

def RandomizedMotifSearch(DNAs, k, t):
  randomMotifs = RandomMotifs(DNAs, k, t)
  bestMotifs = randomMotifs
  i=1
  while i>0:
    profile = Profile(randomMotifs)
    randomMotifs = [ProfileMostProbableKmer(seq,k,profile) for seq in DNAs]
    if Score(randomMotifs)<Score(bestMotifs):
      bestMotifs=randomMotifs
    else:
      return bestMotifs
     
RandomizedMotifSearch(["GGCGTTCAGGCA","AAGAATCAGTCA","CAAGGAGTTCGC","CACGTCAATCAC","CAATAATATTCG"],3,5)

#GibbsSamplingMotifSearch

def GibbsSamplingMotifSearch(DNAs,k,t,N):
  randomMotifs = RandomMotifs(DNAs, k, t)
  bestMotifs = randomMotifs
  for j in range(N):
    i = randint(0, t)
    noIMotif = randomMotifs[0:i]+randomMotifs[i+1:t]
    noIMotifProfile= Profile(noIMotif)
    randomMotifs = [ProfileMostProbableKmer(seq,k,noIMotifProfile) for seq in DNAs]
    if Score(randomMotifs)<Score(bestMotifs):
      bestMotifs=randomMotifs
    else:
      return bestMotifs

GibbsSamplingMotifSearch(["GGCGTTCAGGCA","AAGAATCAGTCA","CAAGGAGTTCGC","CACGTCAATCAC","CAATAATATTCG"],3,5,20)