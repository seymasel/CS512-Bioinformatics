# -*- coding: utf-8 -*-
"""HW6_NurverSeyma_Sel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18UuWHy4qN8XCpn5gyaPN1R6Vm6w67JWt

Nurver Seyma Sel 27927 hw6 https://colab.research.google.com/drive/18UuWHy4qN8XCpn5gyaPN1R6Vm6w67JWt?usp=sharing
"""

#Helper Functions
"""
limblength
input given order n, j, matrix
4
1
0   13  21  22
13  0   12  13
21  12  0   13
22  13  13  0
output: 2


UPGMA
input given order n, j, matrix
4
0   20  17  11
20  0   20  13
17  20  0   10
11  13  10  0
output: 
0->5:7.000
1->6:8.833
2->4:5.000
3->4:5.000
4->2:5.000
4->3:5.000
4->5:2.000
5->0:7.000
5->4:2.000
5->6:1.833
6->5:1.833
6->1:8.833
"""

def LimbLength(n_leaves, j, matrix):
	return min(matrix[i][j] + matrix[k][j] - matrix[i][k] \
		for i in range(n_leaves) for k in range(n_leaves) if i != j and k != j) // 2

 
rows = 4
cols = 4
#FOR LIMBLENGTH INPUT MAT, 4
mat = [[0 for _ in range(cols)] for _ in range(rows)]
mat[0][0], mat[0][1], mat[0][2], mat[0][3] = 0,13,21,22
mat[1][0], mat[1][1], mat[1][2], mat[1][3] = 13,0,12,13
mat[2][0], mat[2][1], mat[2][2], mat[2][3] = 21,12,0,13
mat[3][0], mat[3][1], mat[3][2], mat[3][3] = 22,13,13,0

#FOR UPGMA ROSALIND INPUT MAT1, 4
mat1 = [[0 for _ in range(cols)] for _ in range(rows)]
mat1[0][0], mat1[0][1], mat1[0][2], mat1[0][3] = 0,20,17,11
mat1[1][0], mat1[1][1], mat1[1][2], mat1[1][3] = 20,0,20,13
mat1[2][0], mat1[2][1], mat1[2][2], mat1[2][3] = 17,20,0,10
mat1[3][0], mat1[3][1], mat1[3][2], mat1[3][3] = 11,13,10,0

LimbLength(4,1,mat)

#AdditivePhylogenyProblem
def AdditivePhylogenyRecursive(dMatrix, n):
    if n == 2:
        distance = dMatrix[0][1]
        return { 0:[(1, distance)], 1:[(0, distance)] }

    limbLength = LimbLength(n, n-1, dMatrix)

    for j in range(n):
        dMatrix[j][n] -= limbLength
        dMatrix[n][j] = dMatrix[j][n]

def AdditivePhylogeny(dMatrix, n):
    return AdditivePhylogenyRecursive(dMatrix, n)

tree = AdditivePhylogeny(mat,2)
print("Fitting tree given distance matrix with phylogeny approach:", tree)

#UPGMAProblem
import sys
class Node:
    def __init__(self, label):
        self.age, self.label = 0, label # Age(v) ← 0

class Tree:
    def __init__(self):
        self.edges, self.nodes = [], {}

    def add_node(self, label):
        if label not in self.nodes:
          node = Node(label)
          self.nodes[label] = node
          return node     
        return self.nodes[label]

    def UPGMA(self, distance_mat, n):
        Clusters = {i: [i] for i in range(n)}
        distance_dict = {}

        for i in range(n):
            self.add_node(i)

        for i in range(len(distance_mat)):
            distance_dict[i] = {}
            for j in range(len(distance_mat[i])):
                distance_dict[i][j] = distance_mat[i][j]
        

        newNodeLabel = n
        T = []
        while len(distance_dict) > 1: #while there is more than one cluster
            minDist = sys.maxsize
            nodes = list(distance_dict.keys())
            for i in range(len(nodes) - 1):
                for j in range(i + 1, len(nodes)): #to find closest clusters
                    if distance_dict[nodes[i]][nodes[j]] < minDist:
                        minDist = distance_dict[nodes[i]][nodes[j]] #update min distance
                        nodeI = nodes[i]
                        nodeJ = nodes[j]

            NewCluster = Clusters[nodeI] + Clusters[nodeJ] # merge Ci & Cj to NewCluster

            newNode = self.add_node(newNodeLabel) # add new node labeled
            T.append([newNodeLabel, nodeI]) #connect nodeI & nodeJ
            T.append([newNodeLabel, nodeJ])
            newNode.age = distance_dict[nodeI][nodeJ] / 2 # calculate new node age

            distance_dict[newNodeLabel] = {}
            distance_dict[newNodeLabel][newNodeLabel] = 0
            for oldNode in nodes:
                count,total = 0, 0
                for initNode in Clusters[oldNode]:
                    for node in NewCluster:
                        count = count + 1
                        total = total + distance_mat[initNode][node]
                val = total / count
                distance_dict[oldNode][newNodeLabel] = val
                distance_dict[newNodeLabel][oldNode] = val

            Clusters[newNodeLabel] = NewCluster
            newNodeLabel = newNodeLabel + 1

            del distance_dict[nodeI], distance_dict[nodeJ]
            for key in distance_dict.keys():
                del distance_dict[key][nodeI], distance_dict[key][nodeJ]

        for edge in T:
            length = self.nodes[edge[0]].age - self.nodes[edge[1]].age #length of (v, w) ← Age(v) - Age(w)
            self.edges.append(edge + [length])
            self.edges.append(edge[::-1] + [length])

        self.edges.sort(key=lambda x: x[1])
        self.edges.sort(key=lambda x: x[0])
        return self.edges


tree = Tree()
UPGMAtree = tree.UPGMA(mat1, 4)
print("Fitting tree given distance matrix with UPGMA approach:", UPGMAtree)